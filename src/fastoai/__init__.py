import importlib.metadata
from typing import get_args

try:
    __version__ = importlib.metadata.version(__name__)
except importlib.metadata.PackageNotFoundError:
    __version__ = "1.0.0"

from .applications import FastOAI as FastOAI
from .settings import settings


def literal_to_enum(literal, name) -> str:
    return (
        "\n    ".join(
            [f"class {name}(Enum):"]
            + [f'{item.replace("-", "_")} = "{item}"' for item in get_args(literal)]
        )
        + "\n"
    )


HEADER = """\
# Generated by fastoai, DO NOT EDIT
from datetime import datetime
from enum import Enum
from typing import Annotated, Literal

from fastapi import Depends, HTTPException, status
from fastapi.security.http import HTTPAuthorizationCredentials, HTTPBearer
from openai.types.beta.assistant import ToolResources as AssistantToolResources
from openai.types.beta.assistant_response_format_option import (
    AssistantResponseFormatOption,
)
from openai.types.beta.assistant_tool import AssistantTool
from openai.types.beta.assistant_tool_choice_option import AssistantToolChoiceOption
from openai.types.beta.thread import ToolResources as ThreadToolResources
from openai.types.beta.threads.message import Attachment
from openai.types.beta.threads.message import (
    IncompleteDetails as MessageIncompleteDetails,
)
from openai.types.beta.threads.message_content import MessageContent
from openai.types.beta.threads.run import (
    IncompleteDetails as RunIncompleteDetails,
)
from openai.types.beta.threads.run import (
    LastError as RunLastError,
)
from openai.types.beta.threads.run import (
    RequiredAction,
    TruncationStrategy,
    Usage,
)
from openai.types.beta.threads.runs.run_step import LastError as RunStepLastError
from openai.types.beta.threads.runs.run_step import StepDetails
from pydantic import BaseModel, EmailStr, computed_field, field_serializer
from sqlalchemy.exc import NoResultFound
from sqlmodel import JSON, Column, Field, Relationship, SQLModel

from fastoai.settings import settings
from fastoai.utils import now, random_id_with_prefix

security = HTTPBearer()


class Base(SQLModel):
    created_at: datetime = Field(default_factory=now)
    \"""The Unix timestamp (in seconds) for when the object was created.\"""

    metadata_: dict[str, str] | None = Field(
        None, alias="metadata", sa_type=JSON, sa_column_kwargs={"name": "metadata"}
    )
    \"""Set of 16 key-value pairs that can be attached to an object.

    This can be useful for storing additional information about the object in a
    structured format. Keys can be a maximum of 64 characters long and values can be
    a maxium of 512 characters long.
    \"""

    @field_serializer("created_at")
    def serialize_created_at(self, value: datetime) -> int:
        return int(value.timestamp())

    def model_dump(self, **kwargs):
        result = super().model_dump(**kwargs)
        if "metadata_" in result:
            result["metadata"] = result.pop("metadata_")
        return result
"""

FOOTER = """
class UserSettings(BaseModel):
    \"""User Settings.\"""

    object: Literal["user.settings"] = "user.settings"


class User(SQLModel, table=True):
    \"""User model.\"""

    id: str = Field(default_factory=random_id_with_prefix("user_"), primary_key=True)
    name: str = Field(max_length=150, unique=True, regex=r"^[\\w.@+-]+$")
    password: str
    email: EmailStr | None = Field(nullable=True)
    is_superuser: bool = False
    is_active: bool = True
    created_at: datetime = Field(default_factory=now)
    updated_at: datetime = Field(
        default_factory=now, sa_column_kwargs={"onupdate": now}
    )
    settings: UserSettings = Field(default_factory=dict, sa_column=Column(JSON))
    api_keys: list["APIKey"] = Relationship(back_populates="user")


class APIKey(SQLModel, table=True):
    \"""API key model.

    API key is used for authenticating the user.
    \"""

    __tablename__ = "api_key"

    id: str = Field(default_factory=random_id_with_prefix("sk-"), primary_key=True)
    user_id: str = Field(foreign_key="user.id")
    user: "User" = Relationship(back_populates="api_keys")
    name: str = Field(default="New API key", max_length=255)
    created_at: datetime = Field(default_factory=now)


def get_api_key(api_key: str) -> APIKey | None:
    \"""Get the API key.\"""
    if not settings.auth_enabled:
        return APIKey(id=api_key, user=User(name="test", password="test"))
    try:
        return settings.session.get(APIKey, api_key)
    except NoResultFound:
        return None


def get_current_user(
    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)],
) -> User:
    \"""Get the current user.\"""
    api_key = get_api_key(credentials.credentials)
    if api_key is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid API key"
        )
    return api_key.user


def get_current_active_user(
    user: User = Depends(get_current_user),
) -> User:
    \"""Get the current active user.\"""
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="Inactive user"
        )
    return user
"""


if settings.generate_models:
    import inspect
    import re
    from pathlib import Path

    from openai.types.beta.assistant import Assistant
    from openai.types.beta.thread import Thread
    from openai.types.beta.threads import Message, Run
    from openai.types.beta.threads.run_status import RunStatus
    from openai.types.beta.threads.runs.run_step import RunStep
    from openai.types.file_object import FileObject

    body: list[str] = []
    ID_PREFIXES = {
        "Assistant": "asst_",
        "FileObject": "file-",
        "Thread": "thread_",
        "Message": "msg_",
        "Run": "run_",
        "RunStep": "step_",
    }
    with (Path(__file__).parent / "models.py").open("w", encoding="utf-8") as f:
        f.write(HEADER + "\n\n")
        for m in (Assistant, FileObject, Thread, Message, Run, RunStep):
            src = inspect.getsource(m)
            src = re.sub(
                r"class ([A-Z]\w+)\(BaseModel\)", "class \\1(Base, table=True)", src
            )
            src = re.sub(
                r"(?<= )id: str",
                f'id: str = Field(default_factory=random_id_with_prefix("{ID_PREFIXES[m.__name__]}"), primary_key=True)',
                src,
            )
            src = re.sub(r"List\[(.+)\]", r"list[\1]", src)
            src = re.sub(r"Optional\[(.+)\]", r"\1 | None", src)
            src = re.sub(
                r'\n    metadata: object \| None = None\n    """[\s\S]*?"""\n',
                "",
                src,
                flags=re.MULTILINE,
            )
            src = re.sub(
                r'object: Literal\[("[\w\.]+")\]\n {4}(""".*""")',
                r"@computed_field\n    def object(self) -> Literal[\1]:\n        \2\n        return \1",
                src,
                flags=re.MULTILINE,
            )
            src = re.sub(
                r'\n {4}created_at: int\n {4}""".*"""\n', "", src, flags=re.MULTILINE
            )
            src = re.sub(
                r"[a-z]\w*: list\[[A-Za-z]\w*\](?! \|)",
                r"\g<0> = Field(default_factory=list, sa_column=Column(JSON))",
                src,
            )
            src = re.sub(
                r"([a-z]\w*: list\[[A-Za-z]\w*\] \| None = )None",
                r"\1Field(default=None, sa_column=Column(JSON))",
                src,
            )
            src = re.sub(
                r"([a-z]+)_id: str(?! \|)", r'\g<0> = Field(foreign_key="\1.id")', src
            )
            src = re.sub(
                r"(([a-z]+)_id: str \| None = )None",
                r'\1Field(None, foreign_key="\2.id")',
                src,
            )
            match m.__name__:
                case "Assistant":
                    src = re.sub(
                        r"AssistantResponseFormatOption \| None = None",
                        "AssistantResponseFormatOption | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = re.sub(
                        r"ToolResources \| None = None",
                        "AssistantToolResources | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = "\n    ".join(
                        [
                            src,
                            'messages: list["Message"] = Relationship(back_populates="assistant")\n',
                        ]
                    )
                case "FileObject":
                    src = re.sub(
                        r"class FileObject\(Base, table=True\):",
                        r'\g<0>\n    __tablename__ = "file"',
                        src,
                    )
                    src = re.sub(
                        r"purpose: Literal\[\s*(.+)\s*\]", r"purpose: FilePurpose", src
                    )
                    src = re.sub(
                        r"status: Literal\[\s*(.+)\s*\]", r"status: FileStatus", src
                    )
                    body.append(
                        literal_to_enum(
                            FileObject.model_fields["purpose"].annotation, "FilePurpose"
                        )
                    )
                    body.append(
                        literal_to_enum(
                            FileObject.model_fields["status"].annotation, "FileStatus"
                        )
                    )
                case "Thread":
                    src = re.sub(
                        r"ToolResources \| None = None",
                        "ThreadToolResources | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = "\n    ".join(
                        [
                            src,
                            'messages: list["Message"] = Relationship(back_populates="thread")\n',
                        ]
                    )
                case "Message":
                    src = re.sub(
                        r"IncompleteDetails \| None = None",
                        "MessageIncompleteDetails | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = re.sub(
                        r"role: Literal\[\s*(.+)\s*\]", r"role: MessageRole", src
                    )
                    src = re.sub(
                        r"status: Literal\[\s*(.+)\s*\]", r"status: MessageStatus", src
                    )
                    src = "\n    ".join(
                        [
                            src,
                            'assistant: Assistant = Relationship(back_populates="messages")\n',
                            'thread: Thread = Relationship(back_populates="messages")\n',
                            'run: "Run | None" = Relationship(back_populates="message")\n',
                        ]
                    )
                    body.append(
                        literal_to_enum(
                            Message.model_fields["role"].annotation, "MessageRole"
                        )
                    )
                    body.append(
                        literal_to_enum(
                            Message.model_fields["status"].annotation, "MessageStatus"
                        )
                    )
                case "Run":
                    src = re.sub(
                        r"IncompleteDetails \| None = None",
                        "RunIncompleteDetails | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = re.sub(
                        r"LastError \| None = None",
                        "RunLastError | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = re.sub(
                        r"RequiredAction \| None = None",
                        "RequiredAction | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = re.sub(
                        r"AssistantResponseFormatOption \| None = None",
                        "AssistantResponseFormatOption | None = Field(\n        None, sa_column=Column(JSON)\n    )",
                        src,
                    )
                    src = re.sub(
                        r"AssistantToolChoiceOption \| None = None",
                        "AssistantToolChoiceOption | None = Field(None, sa_column=Column(JSON))",
                        src,
                    )
                    src = re.sub(
                        r"TruncationStrategy \| None = None",
                        "TruncationStrategy | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = re.sub(
                        r"Usage \| None = None",
                        "Usage | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = "\n    ".join(
                        [
                            src,
                            'assistant: Assistant = Relationship(back_populates="runs")\n',
                            'thread: Thread = Relationship(back_populates="runs")\n',
                            'message: "Message" = Relationship(\n'
                            '        sa_relationship_kwargs={"uselist": False}, back_populates="run"\n'
                            "    )\n",
                            'steps: list["RunStep"] = Relationship(back_populates="run")\n',
                        ]
                    )
                    body.append(literal_to_enum(RunStatus, "RunStatus"))
                case "RunStep":
                    src = re.sub(
                        r"LastError \| None = None",
                        "RunStepLastError | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = re.sub(
                        r"status: Literal\[\s*(.+)\s*\]", r"status: RunStepStatus", src
                    )
                    src = re.sub(
                        r"type: Literal\[\s*(.+)\s*\]", r"type: RunStepType", src
                    )
                    src = re.sub(
                        r"step_details: StepDetails",
                        r"step_details: StepDetails = Field(sa_column=Column(JSON))",
                        src,
                    )
                    src = re.sub(
                        r"Usage \| None = None",
                        "Usage | None = Field(None, sa_type=JSON)",
                        src,
                    )
                    src = "\n    ".join(
                        [
                            src,
                            'run: Run = Relationship(back_populates="steps")\n',
                        ]
                    )
                    body.append(
                        literal_to_enum(
                            RunStep.model_fields["status"].annotation, "RunStepStatus"
                        )
                    )
                    body.append(
                        literal_to_enum(
                            RunStep.model_fields["type"].annotation, "RunStepType"
                        )
                    )
            body.append(src)
        f.write("\n\n".join(body))
        f.write("\n")
        f.write(FOOTER)
