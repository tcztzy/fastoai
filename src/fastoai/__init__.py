import importlib.metadata
import inspect
import re
from pathlib import Path
from typing import get_args

try:
    __version__ = importlib.metadata.version(__name__)
except importlib.metadata.PackageNotFoundError:
    __version__ = "1.0.0"

from .applications import FastOAI as FastOAI
from .settings import settings


def literal_to_enum(literal, name) -> str:
    return (
        "\n    ".join(
            [f"class {name}(Enum):"]
            + [f'{item.replace("-", "_")} = "{item}"' for item in get_args(literal)]
        )
        + "\n"
    )


if settings.generate_models:
    HEADER = """\
# Generated by fastoai, DO NOT EDIT
from datetime import datetime
from enum import Enum
from typing import Annotated, Any, Literal, Self

from fastapi import Depends, HTTPException, status
from fastapi.security.http import HTTPAuthorizationCredentials, HTTPBearer
from openai.types.beta.assistant import ToolResources as AssistantToolResources
from openai.types.beta.assistant_response_format_option import (
    AssistantResponseFormatOption,
)
from openai.types.beta.assistant_tool import AssistantTool
from openai.types.beta.assistant_tool_choice_option import AssistantToolChoiceOption
from openai.types.beta.thread import ToolResources as ThreadToolResources
from openai.types.beta.threads.message import Attachment
from openai.types.beta.threads.message import (
    IncompleteDetails as MessageIncompleteDetails,
)
from openai.types.beta.threads.message_content import MessageContent
from openai.types.beta.threads.run import (
    IncompleteDetails as RunIncompleteDetails,
)
from openai.types.beta.threads.run import (
    LastError as RunLastError,
)
from openai.types.beta.threads.run import (
    RequiredAction,
    TruncationStrategy,
    Usage,
)
from openai.types.beta.threads.runs.run_step import LastError as RunStepLastError
from openai.types.beta.threads.runs.run_step import StepDetails
from pydantic import BaseModel, EmailStr, computed_field, field_serializer
from sqlalchemy.exc import NoResultFound
from sqlmodel import JSON, Column, Field, Relationship, SQLModel

from fastoai.settings import settings
from fastoai.utils import now, random_id_with_prefix

security = HTTPBearer()


class MetadataMixin(SQLModel):
    metadata_: dict[str, str] | None = Field(
        None, alias="metadata", sa_type=JSON, sa_column_kwargs={"name": "metadata"}
    )
    \"""Set of 16 key-value pairs that can be attached to an object.

    This can be useful for storing additional information about the object in a
    structured format. Keys can be a maximum of 64 characters long and values can be
    a maxium of 512 characters long.
    \"""

    @classmethod
    def model_validate(
        cls,
        obj: Any,
        *,
        strict: bool | None = None,
        from_attributes: bool | None = None,
        context: dict[str, Any] | None = None,
        update: dict[str, Any] | None = None,
    ) -> Self:
        if "metadata" in obj:
            obj["metadata_"] = obj.pop("metadata")
        return super().model_validate(
            obj,
            strict=strict,
            from_attributes=from_attributes,
            context=context,
            update=update,
        )

    def model_dump(self, **kwargs):
        result = super().model_dump(**kwargs)
        if "metadata_" in result:
            result["metadata"] = result.pop("metadata_")
        return result

    def model_dump_json(self, **kwargs):
        result = super().model_dump_json(**kwargs)
        if "metadata_" in result:
            result.replace("metadata_", "metadata")
        return result

    def __init__(self, **kwargs):
        if "metadata" in kwargs:
            kwargs["metadata_"] = kwargs.pop("metadata")
        return super().__init__(**kwargs)


class Base(SQLModel):
    created_at: datetime = Field(default_factory=now)
    \"""The Unix timestamp (in seconds) for when the object was created.\"""

    @field_serializer("created_at")
    def serialize_created_at(self, value: datetime) -> int:
        return int(value.timestamp())
"""

    FOOTER = """class UserSettings(BaseModel):
    \"""User Settings.\"""

    object: Literal["user.settings"] = "user.settings"


class User(SQLModel, table=True):
    \"""User model.\"""

    id: str = Field(default_factory=random_id_with_prefix("user_"), primary_key=True)
    name: str = Field(max_length=150, unique=True, regex=r"^[\\w.@+-]+$")
    password: str
    email: EmailStr | None = Field(nullable=True)
    is_superuser: bool = False
    is_active: bool = True
    created_at: datetime = Field(default_factory=now)
    updated_at: datetime = Field(
        default_factory=now, sa_column_kwargs={"onupdate": now}
    )
    settings: UserSettings = Field(default_factory=dict, sa_column=Column(JSON))
    api_keys: list["APIKey"] = Relationship(back_populates="user")


class APIKey(SQLModel, table=True):
    \"""API key model.

    API key is used for authenticating the user.
    \"""

    __tablename__ = "api_key"

    id: str = Field(default_factory=random_id_with_prefix("sk-"), primary_key=True)
    user_id: str = Field(foreign_key="user.id")
    user: "User" = Relationship(back_populates="api_keys")
    name: str = Field(default="New API key", max_length=255)
    created_at: datetime = Field(default_factory=now)


def get_api_key(api_key: str) -> APIKey | None:
    \"""Get the API key.\"""
    if not settings.auth_enabled:
        return APIKey(id=api_key, user=User(name="test", password="test"))
    try:
        return settings.session.get(APIKey, api_key)
    except NoResultFound:
        return None


def get_current_user(
    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)],
) -> User:
    \"""Get the current user.\"""
    api_key = get_api_key(credentials.credentials)
    if api_key is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid API key"
        )
    return api_key.user


def get_current_active_user(
    user: User = Depends(get_current_user),
) -> User:
    \"""Get the current active user.\"""
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="Inactive user"
        )
    return user
"""

    from openai.types.beta.assistant import Assistant
    from openai.types.beta.thread import Thread
    from openai.types.beta.threads import Message, Run
    from openai.types.beta.threads.run_status import RunStatus
    from openai.types.beta.threads.runs.run_step import RunStep
    from openai.types.file_object import FileObject

    body: list[str] = []
    ID_PREFIXES = {
        "Assistant": "asst_",
        "FileObject": "file-",
        "Thread": "thread_",
        "Message": "msg_",
        "Run": "run_",
        "RunStep": "step_",
    }
    for m in (Assistant, FileObject, Thread, Run, Message, RunStep):
        src = inspect.getsource(m)
        if m in (Assistant, Thread, Message, Run, RunStep):
            src = re.sub(
                r"class ([A-Z]\w+)\(BaseModel\)",
                "class \\1(Base, MetadataMixin, table=True)",
                src,
            )
        else:
            src = re.sub(
                r"class ([A-Z]\w+)\(BaseModel\)", "class \\1(Base, table=True)", src
            )
        src = re.sub(
            r"(?<= )id: str",
            f'id: str = Field(default_factory=random_id_with_prefix("{ID_PREFIXES[m.__name__]}"), primary_key=True)',
            src,
        )
        src = re.sub(r"List\[(.+)\]", r"list[\1]", src)
        src = re.sub(r"Optional\[(.+)\]", r"\1 | None", src)
        src = re.sub(
            r'\n    metadata: object \| None = None\n    """[\s\S]*?"""\n',
            "",
            src,
            flags=re.MULTILINE,
        )
        src = re.sub(
            r'object: Literal\[("[\w\.]+")\]\n {4}(""".*""")',
            r"@computed_field\n    def object(self) -> Literal[\1]:\n        \2\n        return \1",
            src,
            flags=re.MULTILINE,
        )
        src = re.sub(
            r'\n {4}created_at: int\n {4}""".*"""\n', "", src, flags=re.MULTILINE
        )
        timestamps = re.findall(r"(\w+_at): int \| None = None", src)
        for timestamp in timestamps:
            src = re.sub(
                rf"{timestamp}: int \| None = None",
                f"{timestamp}: datetime | None = None",
                src,
            )
        if len(timestamps) > 0:
            fields = ", ".join(f'"{timestamp}"' for timestamp in timestamps)
            if len(fields) + len("    @field_serializer()") > 88:
                if len(fields) + 8 <= 88:
                    fields = f"\n        {fields}\n    "
                else:
                    fields = ",\n        ".join(
                        f'"{timestamp}"' for timestamp in timestamps
                    )
            src += f"""
    @field_serializer({fields})
    def serialize_{timestamp}(self, value: datetime | None) -> int | None:
        if value is None:
            return None
        return int(value.timestamp())
"""
        src = re.sub(
            r"[a-z]\w*: list\[[A-Za-z]\w*\](?! \|)",
            r"\g<0> = Field(default_factory=list, sa_column=Column(JSON))",
            src,
        )
        src = re.sub(
            r"([a-z]\w*: list\[[A-Za-z]\w*\] \| None = )None",
            r"\1Field(default=None, sa_column=Column(JSON))",
            src,
        )
        src = re.sub(
            r"([a-z]+)_id: str(?! \|)", r'\g<0> = Field(foreign_key="\1.id")', src
        )
        src = re.sub(
            r"(([a-z]+)_id: str \| None = )None",
            r'\1Field(None, foreign_key="\2.id")',
            src,
        )
        match m.__name__:
            case "Assistant":
                src = re.sub(
                    r"AssistantResponseFormatOption \| None = None",
                    "AssistantResponseFormatOption | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = re.sub(
                    r"ToolResources \| None = None",
                    "AssistantToolResources | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = "\n    ".join(
                    [
                        src,
                        'messages: list["Message"] = Relationship(back_populates="assistant")\n',
                        'runs: list["Run"] = Relationship(back_populates="assistant")\n',
                    ]
                )
            case "FileObject":
                src = re.sub(
                    r"class FileObject\(Base, table=True\):",
                    r'\g<0>\n    __tablename__ = "file"',
                    src,
                )
                src = re.sub(
                    r"purpose: Literal\[\s*(.+)\s*\]", r"purpose: FilePurpose", src
                )
                src = re.sub(
                    r"status: Literal\[\s*(.+)\s*\]", r"status: FileStatus", src
                )
                body.append(
                    literal_to_enum(
                        FileObject.model_fields["purpose"].annotation, "FilePurpose"
                    )
                )
                body.append(
                    literal_to_enum(
                        FileObject.model_fields["status"].annotation, "FileStatus"
                    )
                )
            case "Thread":
                src = re.sub(
                    r"ToolResources \| None = None",
                    "ThreadToolResources | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = "\n    ".join(
                    [
                        src,
                        'messages: list["Message"] = Relationship(back_populates="thread")\n',
                        'runs: list["Run"] = Relationship(back_populates="thread")\n',
                    ]
                )
            case "Message":
                src = re.sub(
                    r"IncompleteDetails \| None = None",
                    "MessageIncompleteDetails | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = re.sub(r"role: Literal\[\s*(.+)\s*\]", r"role: MessageRole", src)
                src = re.sub(
                    r"status: Literal\[\s*(.+)\s*\]", r"status: MessageStatus", src
                )
                src = "\n    ".join(
                    [
                        src,
                        'assistant: Assistant = Relationship(back_populates="messages")\n',
                        'thread: Thread = Relationship(back_populates="messages")\n',
                        'run: Run | None = Relationship(back_populates="message")\n',
                    ]
                )
                body.append(
                    literal_to_enum(
                        Message.model_fields["role"].annotation, "MessageRole"
                    )
                )
                body.append(
                    literal_to_enum(
                        Message.model_fields["status"].annotation, "MessageStatus"
                    )
                )
            case "Run":
                src = re.sub(
                    r"IncompleteDetails \| None = None",
                    "RunIncompleteDetails | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = re.sub(
                    r"LastError \| None = None",
                    "RunLastError | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = re.sub(
                    r"RequiredAction \| None = None",
                    "RequiredAction | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = re.sub(
                    r"AssistantResponseFormatOption \| None = None",
                    "AssistantResponseFormatOption | None = Field(\n        None, sa_column=Column(JSON)\n    )",
                    src,
                )
                src = re.sub(
                    r"AssistantToolChoiceOption \| None = None",
                    "AssistantToolChoiceOption | None = Field(None, sa_column=Column(JSON))",
                    src,
                )
                src = re.sub(
                    r"TruncationStrategy \| None = None",
                    "TruncationStrategy | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = re.sub(
                    r"Usage \| None = None",
                    "Usage | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = "\n    ".join(
                    [
                        src,
                        'assistant: Assistant = Relationship(back_populates="runs")\n',
                        'thread: Thread = Relationship(back_populates="runs")\n',
                        'message: "Message" = Relationship(\n'
                        '        sa_relationship_kwargs={"uselist": False}, back_populates="run"\n'
                        "    )\n",
                        'steps: list["RunStep"] = Relationship(back_populates="run")\n',
                    ]
                )
                body.append(literal_to_enum(RunStatus, "RunStatus"))
            case "RunStep":
                src = re.sub(
                    r"LastError \| None = None",
                    "RunStepLastError | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = re.sub(
                    r"status: Literal\[\s*(.+)\s*\]", r"status: RunStepStatus", src
                )
                src = re.sub(r"type: Literal\[\s*(.+)\s*\]", r"type: RunStepType", src)
                src = re.sub(
                    r"step_details: StepDetails",
                    r"step_details: StepDetails = Field(sa_column=Column(JSON))",
                    src,
                )
                src = re.sub(
                    r"Usage \| None = None",
                    "Usage | None = Field(None, sa_type=JSON)",
                    src,
                )
                src = "\n    ".join(
                    [
                        src,
                        'run: Run = Relationship(back_populates="steps")\n',
                    ]
                )
                body.append(
                    literal_to_enum(
                        RunStep.model_fields["status"].annotation, "RunStepStatus"
                    )
                )
                body.append(
                    literal_to_enum(
                        RunStep.model_fields["type"].annotation, "RunStepType"
                    )
                )
        body.append(src)

    with (Path(__file__).parent / "models.py").open("w", encoding="utf-8") as f:
        f.write("\n\n".join([HEADER] + body + [FOOTER]))


if settings.generate_requests:
    from openai.types.beta.assistant_create_params import AssistantCreateParams
    from openai.types.beta.assistant_update_params import AssistantUpdateParams
    from openai.types.beta.thread_create_params import ThreadCreateParams
    from openai.types.beta.threads.message_create_params import MessageCreateParams
    from openai.types.beta.threads.run_create_params import RunCreateParamsBase
    from openai.types.chat.completion_create_params import CompletionCreateParamsBase

    HEADER = """\
# Generated by fastoai, DO NOT EDIT
from typing import Literal

from openai.types.beta.assistant import ToolResources
from openai.types.beta.assistant_response_format_option_param import (
    AssistantResponseFormatOptionParam,
)
from openai.types.beta.assistant_tool_choice_option_param import (
    AssistantToolChoiceOptionParam,
)
from openai.types.beta.assistant_tool_param import AssistantToolParam
from openai.types.beta.thread_create_params import Message
from openai.types.beta.threads.message_content_part_param import MessageContentPartParam
from openai.types.beta.threads.message_create_params import Attachment
from openai.types.beta.threads.run_create_params import (
    AdditionalMessage,
    TruncationStrategy,
)
from openai.types.chat.chat_completion_message_param import ChatCompletionMessageParam
from openai.types.chat.chat_completion_stream_options_param import (
    ChatCompletionStreamOptionsParam,
)
from openai.types.chat.chat_completion_tool_choice_option_param import (
    ChatCompletionToolChoiceOptionParam,
)
from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from openai.types.chat.completion_create_params import (
    Function,
    FunctionCall,
    ResponseFormat,
)
from openai.types.shared_params import ResponseFormatText
from pydantic import BaseModel
"""
    body = []

    for params in (
        AssistantCreateParams,
        AssistantUpdateParams,
        ThreadCreateParams,
        MessageCreateParams,
        RunCreateParamsBase,
        CompletionCreateParamsBase,
    ):
        src = inspect.getsource(params)
        src = re.sub(
            r"class ([A-Z]\w+)\(TypedDict, total=False\):",
            r"class \1(BaseModel):",
            src,
        )
        src = re.sub(r"Required\[\s*(.+)\s*\]", r"\1", src, flags=re.MULTILINE)
        src = re.sub(r"List\[(.+?)\]", r"list[\1]", src)
        src = re.sub(r"Dict\[(.+?)\]", r"dict[\1]", src)
        src = re.sub(r"Iterable\[(.+)\]", r"list[\1]", src)
        src = re.sub(r"Optional\[(.+)\]", r"\1 | None = None", src)
        match params.__name__:
            case "AssistantCreateParams":
                src = re.sub(
                    r'model: [\s\S]+?"""',
                    'model: str\n    """',
                    src,
                    flags=re.MULTILINE,
                )
            case "AssistantUpdateParams":
                src = re.sub("tools: .+", r"\g<0> = []", src)
            case "MessageCreateParams":
                src = re.sub(
                    "content: .+", "content: str | list[MessageContentPartParam]", src
                )
            case "ThreadCreateParams":
                src = re.sub("messages: .+", r"\g<0> = []", src)
            case "RunCreateParamsBase":
                src = re.sub("RunCreateParamsBase", "RunCreateParams", src)
                src = re.sub(
                    r'model: [\s\S]+?"""',
                    'model: str\n    """',
                    src,
                    flags=re.MULTILINE,
                )
                src = re.sub(
                    "parallel_tool_calls: .+", "parallel_tool_calls: bool = True", src
                )
                src += "\n    stream: bool = False\n"
            case "CompletionCreateParamsBase":
                src = re.sub(
                    "CompletionCreateParamsBase", "CompletionCreateParams", src
                )
                src = re.sub(
                    "messages: .+", "message: list[ChatCompletionMessageParam]", src
                )
                src = re.sub("model: .+", "model: str", src)
                src = re.sub(
                    "parallel_tool_calls: .+", "parallel_tool_calls: bool = True", src
                )
                src = re.sub(
                    "response_format: .+", r"\g<0> = ResponseFormatText()", src
                )
                src = re.sub("tool_choice: .+", r"\g<0> | None = None", src)
                src = re.sub("tools: .+", r"\g<0> = []", src)
                src = re.sub("function_call: .+", r"\g<0> | None = None", src)
                src = re.sub("functions: .+", r"\g<0> = []", src)
                src = re.sub("user: str", "user: str | None = None", src)
                src = re.sub(r"stop: .+", "stop: str | list[str] | None = None", src)
                src += """
    stream: bool = False
    \"""If set, partial message deltas will be sent, like in ChatGPT.

    Tokens will be sent as data-only
    [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)
    as they become available, with the stream terminated by a `data: [DONE]`
    message.
    [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
    \"""

    def model_post_init(self, __context):
        if self.function_call is None:
            self.function_call = "auto" if len(self.functions) > 0 else "none"
        if self.tool_choice is None:
            self.tool_choice = "auto" if len(self.tools) > 0 else "none"
"""
        body.append(src)

    with Path(__file__).parent.joinpath("requests.py").open("w", encoding="utf-8") as f:
        f.write("\n\n".join([HEADER] + body))
